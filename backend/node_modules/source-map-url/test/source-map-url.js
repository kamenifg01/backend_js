// Copyright 2014 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)

var expect = require("expect.js")

var sourceMappingURL = require("../")

var comments = {

  universal: [
    "/*# sourceMappingURL=foo.js.map */"
  ],

  js: [
    "//# sourceMappingURL=foo.js.map"
  ],

  block: [
    "/*",
    "# sourceMappingURL=foo.js.map",
    "*/"
  ],

  mix: [
    "/*",
    "//# sourceMappingURL=foo.js.map",
    "*/"
  ]

}

var nonTrailingComments = {

  jsLeading: {
    contents: [
      "//# sourceMappingURL=foo.js.map",
      "(function(){})"
    ],
    solution: [
      "(function(){})"
    ]
  },

  mixEmbedded: {
    contents: [
      "/*! Library Name v1.0.0",
      "//# sourceMappingURL=foo.js.map",
      "*/",
      "(function(){})"
    ],
    solution: [
      "/*! Library Name v1.0.0",
      "*/",
      "(function(){})"
    ]
  }

}

function forEachComment(fn) {
  forOf(comments, function(name, comment) {
    var description = "the '" + name + "' syntax with "
    fn(comment.join("\n"),   description + "regular newlines")
    fn(comment.join("\r\n"), description + "Windows newlines")
  })
}

function forEachNonTrailingComment(fn) {
  forOf(nonTrailingComments, function(name, comment) {

    var description = "the '" + name + "' syntax with "

    fn({
      contents: comment.contents.join("\n"),
      solution: comment.solution.join("\n")
    }, description + "regular newlines")

    fn({
      contents: comment.contents.join("\r\n"),
      solution: comment.solution.join("\r\n")
    }, description + "Windows newlines")
  })
}

function forOf(obj, fn) {
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      fn(key, obj[key])
    }
  }
}


describe("sourceMappingURL", function() {

  describe(".getFrom", function() {

    forEachComment(function(comment, description) {

      it("gets the url from " + description, function() {
        expect(sourceMappingURL.getFrom("code\n" + comment))
          .to.equal("foo.js.map")

        expect(sourceMappingURL.getFrom("code" + comment))
          .to.equal("foo.js.map")

        expect(sourceMappingURL.getFrom(comment))
          .to.equal("foo.js.map")
      })

    })

    forEachNonTrailingComment(function(comment, description) {

      it("gets the url from " + description, function() {
        expect(sourceMappingURL.getFrom("code\n" + comment.contents))
          .to.equal("foo.js.map")

        expect(sourceMappingURL.getFrom("code" + comment.contents))
          .to.equal("foo.js.map")

        expect(sourceMappingURL.getFrom(comment.contents))
          .to.equal("foo.js.map")
      })

    })


    it("returns null if no comment", function() {
      expect(sourceMappingURL.getFrom("code"))
        .to.equal(null)
    })


    it("can return an empty string as url", function() {
      expect(sourceMappingURL.getFrom("/*# sourceMappingURL= */"))
        .to.equal("")
    })


    it("is detachable", function() {
      var get = sourceMappingURL.getFrom
      expect(get("/*# sourceMappingURL=foo */"))
        .to.equal("foo")
    })

  })


  describe(".existsIn", function() {

    forEachComment(function(comment, description) {

      it("returns true